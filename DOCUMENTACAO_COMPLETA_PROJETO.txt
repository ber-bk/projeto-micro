================================================================================
                              INDICE DO DOCUMENTO
================================================================================

1. VISAO GERAL DO PROJETO
2. MODULO 1: main.py
3. MODULO 2: database.py
4. MODULO 3: criar_missao.py
5. MODULO 4: visualizar_missoes.py
6. MODULO 5: sensor_arduino.py
7. MODULO 6: gravacao_video.py
8. MODULO 7: gravacao_audio.py
9. MODULO 8: sensor_e_temperatura.ino (Arduino)

================================================================================
                          1. VISAO GERAL DO PROJETO
================================================================================

Nome: Sistema de Monitoramento de Mergulhos
Proposito: Monitorar missoes de mergulho atraves de sensores de temperatura e
           pressao, gravando video e audio de forma sincronizada.

Tecnologias Principais:
- Linguagem: Python 3.8+
- Interface Grafica: Tkinter
- Banco de Dados: SQLite
- Hardware: Arduino com sensores DS18B20 (temperatura) e sensor de pressao
- Captura de Video: OpenCV
- Captura de Audio: PyAudio

Funcionalidades Principais:
1. Cadastro de mergulhadores
2. Criacao e gerenciamento de missoes
3. Gravacao automatica de video em segmentos de 5 minutos
4. Gravacao automatica de audio em segmentos de 5 minutos
5. Leitura continua de sensores (temperatura e pressao)
6. Armazenamento de dados em banco relacional
7. Visualizacao de missoes antigas
8. Reproducao sincronizada de video e audio
9. Visualizacao ao vivo de missoes em andamento
10. Estatisticas de medicoes (min/max/media)





================================================================================
                          2. MODULO 1: main.py
================================================================================

ARQUIVO: main.py
DESCRICAO: Interface grafica principal do sistema. Ponto de entrada da aplicacao.

--------------------------------------------------------------------------------
                              CLASSE PRINCIPAL
--------------------------------------------------------------------------------

CLASSE: SistemaMergulhoApp
Responsabilidade: Gerenciar a janela principal e navegacao do sistema

ATRIBUTOS:
- root: Referencia para a janela principal Tkinter

METODOS:

1. __init__(self, root)
   Parametros: root (Tk) - janela raiz do Tkinter
   Retorno: None
   Descricao: Construtor da classe. Inicializa a interface principal.
   Acoes:
   - Define titulo e dimensoes da janela (600x500)
   - Centraliza a janela na tela
   - Configura estilos visuais
   - Inicializa o banco de dados
   - Cria a interface grafica

2. centralizar_janela(self)
   Parametros: None
   Retorno: None
   Descricao: Centraliza a janela na tela do usuario
   Algoritmo:
   - Obtem largura e altura da janela
   - Calcula posicao X: (largura_tela / 2) - (largura_janela / 2)
   - Calcula posicao Y: (altura_tela / 2) - (altura_janela / 2)
   - Aplica a geometria calculada

3. configurar_estilo(self)
   Parametros: None
   Retorno: None
   Descricao: Configura o tema visual da aplicacao
   Estilos Definidos:
   - Theme: 'clam'
   - Main.TButton: Botoes principais (azul #1a5490, fonte Arial 12)
   - Title.TLabel: Titulos (azul #1a5490, fonte Arial 20 bold)
   - Subtitle.TLabel: Subtitulos (cinza #666666, fonte Arial 10)

4. criar_interface(self)
   Parametros: None
   Retorno: None
   Descricao: Cria todos os elementos visuais da tela principal
   Componentes Criados:
   - Frame principal com cor de fundo #f0f0f0
   - Titulo: "Sistema de Monitoramento de Mergulhos"
   - Label com data/hora atual
   - Botao "Criar Nova Missao" (350x60px)
   - Botao "Visualizar Missoes" (350x60px)
   - Rodape com informacoes do projeto
   - Label com caminho do banco de dados

5. criar_nova_missao(self)
   Parametros: None
   Retorno: None
   Descricao: Callback do botao "Criar Nova Missao"
   Acao: Abre janela de criacao de missao (CriarMissaoWindow)

6. visualizar_missao(self)
   Parametros: None
   Retorno: None
   Descricao: Callback do botao "Visualizar Missoes"
   Acao: Abre janela de visualizacao de missoes (VisualizarMissoesWindow)

--------------------------------------------------------------------------------
                              FUNCAO PRINCIPAL
--------------------------------------------------------------------------------

FUNCAO: main()
Parametros: None
Retorno: None
Descricao: Funcao de entrada da aplicacao
Fluxo:
1. Cria janela raiz do Tkinter
2. Instancia SistemaMergulhoApp
3. Inicia loop de eventos (mainloop)

PONTO DE ENTRADA:
if __name__ == "__main__":
    main()


================================================================================
                          3. MODULO 2: database.py
================================================================================

ARQUIVO: database.py
DESCRICAO: Gerenciamento completo do banco de dados SQLite

--------------------------------------------------------------------------------
                              CONSTANTES E CONFIGURACOES
--------------------------------------------------------------------------------

DB_PATH = 'mergulho.db'  # Caminho do banco de dados

--------------------------------------------------------------------------------
                              FUNCOES UTILITARIAS
--------------------------------------------------------------------------------

1. conectar()
   Parametros: None
   Retorno: sqlite3.Connection
   Descricao: Cria e retorna uma conexao com o banco de dados
   Uso: Sempre usar com context manager ou fechar manualmente

2. inicializar_banco()
   Parametros: None
   Retorno: None
   Descricao: Cria todas as tabelas se nao existirem
   Tabelas Criadas:
   - mergulhador (id_mergulhador, nome, idade, sexo)
   - missao (id_missao, identificador, id_mergulhador, nome_missao,
             data_hora_inicio, data_hora_fim)
   - medicao (id_medicao, id_missao, timestamp, temperatura, pressao)
   - video (id_video, id_missao, caminho)
   - audio (id_audio, id_missao, caminho)

--------------------------------------------------------------------------------
                         OPERACOES DE MERGULHADOR
--------------------------------------------------------------------------------

3. inserir_mergulhador(nome, idade, sexo)
   Parametros:
   - nome (str): Nome completo do mergulhador
   - idade (int): Idade em anos (deve ser > 0)
   - sexo (str): 'M', 'F' ou 'O'
   Retorno: int - ID do mergulhador inserido
   Descricao: Insere um novo mergulhador no banco
   SQL: INSERT INTO mergulhador (nome, idade, sexo) VALUES (?, ?, ?)

4. listar_mergulhadores()
   Parametros: None
   Retorno: list[tuple] - Lista de tuplas (id, nome, idade, sexo)
   Descricao: Retorna todos os mergulhadores ordenados por nome
   SQL: SELECT * FROM mergulhador ORDER BY nome

5. buscar_mergulhador(id_mergulhador)
   Parametros: id_mergulhador (int)
   Retorno: tuple ou None - (id, nome, idade, sexo)
   Descricao: Busca um mergulhador especifico pelo ID
   SQL: SELECT * FROM mergulhador WHERE id_mergulhador = ?

--------------------------------------------------------------------------------
                         OPERACOES DE MISSAO
--------------------------------------------------------------------------------

6. inserir_missao(id_mergulhador, nome_missao, data_hora_inicio,
                  identificador, data_hora_fim=None)
   Parametros:
   - id_mergulhador (int): ID do mergulhador
   - nome_missao (str): Nome/descricao da missao
   - data_hora_inicio (str): Formato 'YYYY-MM-DD HH:MM:SS'
   - identificador (str): Identificador unico (formato: Missao_DD-MM-AA_HH-MM)
   - data_hora_fim (str, opcional): Data/hora de termino
   Retorno: int - ID da missao inserida
   Descricao: Cria uma nova missao no banco
   Validacoes:
   - id_mergulhador deve existir
   - identificador deve ser unico
   SQL: INSERT INTO missao (id_mergulhador, nome_missao, data_hora_inicio,
                            identificador, data_hora_fim) VALUES (?, ?, ?, ?, ?)

7. atualizar_fim_missao(id_missao, data_hora_fim)
   Parametros:
   - id_missao (int): ID da missao
   - data_hora_fim (str): Data/hora de termino (formato: 'YYYY-MM-DD HH:MM:SS')
   Retorno: None
   Descricao: Atualiza a data/hora de termino de uma missao
   Uso: Chamado ao finalizar uma missao
   SQL: UPDATE missao SET data_hora_fim = ? WHERE id_missao = ?

8. listar_missoes()
   Parametros: None
   Retorno: list[tuple] - Lista de tuplas com dados completos
   Formato de Retorno: (id_missao, identificador, nome_missao,
                        data_hora_inicio, data_hora_fim, nome_mergulhador,
                        idade_mergulhador, sexo_mergulhador)
   Descricao: Lista todas as missoes com dados do mergulhador (JOIN)
   Ordenacao: Data/hora de inicio descendente (mais recentes primeiro)
   SQL: SELECT m.id_missao, m.identificador, m.nome_missao,
               m.data_hora_inicio, m.data_hora_fim, mg.nome, mg.idade, mg.sexo
        FROM missao m
        JOIN mergulhador mg ON m.id_mergulhador = mg.id_mergulhador
        ORDER BY m.data_hora_inicio DESC

9. buscar_missao(id_missao)
   Parametros: id_missao (int)
   Retorno: tuple ou None - Dados completos da missao
   Formato: (id_missao, identificador, id_mergulhador, nome_missao,
             data_hora_inicio, data_hora_fim, nome_mergulhador,
             idade_mergulhador, sexo_mergulhador)
   Descricao: Busca uma missao especifica com dados do mergulhador
   SQL: SELECT ... FROM missao m JOIN mergulhador mg ... WHERE id_missao = ?

10. verificar_missao_em_andamento()
    Parametros: None
    Retorno: tuple ou None
    Formato: (id_missao, identificador, nome_missao, data_hora_inicio,
              nome_mergulhador)
    Descricao: Verifica se existe missao sem data_hora_fim (em andamento)
    Criterio: data_hora_fim IS NULL
    SQL: SELECT m.id_missao, m.identificador, m.nome_missao,
                m.data_hora_inicio, mg.nome
         FROM missao m
         JOIN mergulhador mg ON m.id_mergulhador = mg.id_mergulhador
         WHERE m.data_hora_fim IS NULL
         ORDER BY m.data_hora_inicio DESC
         LIMIT 1

--------------------------------------------------------------------------------
                         OPERACOES DE MEDICAO
--------------------------------------------------------------------------------

11. inserir_medicao(id_missao, timestamp, temperatura, pressao)
    Parametros:
    - id_missao (int): ID da missao
    - timestamp (str): Data/hora da medicao (formato: 'YYYY-MM-DD HH:MM:SS')
    - temperatura (float): Temperatura em graus Celsius
    - pressao (float): Pressao em PSI
    Retorno: int - ID da medicao inserida
    Descricao: Insere uma leitura de sensor
    Frequencia: A cada 1 minuto durante a missao
    SQL: INSERT INTO medicao (id_missao, timestamp, temperatura, pressao)
         VALUES (?, ?, ?, ?)

12. listar_medicoes_por_missao(id_missao)
    Parametros: id_missao (int)
    Retorno: list[tuple] - Lista de medicoes
    Formato: (id_medicao, id_missao, timestamp, temperatura, pressao)
    Descricao: Retorna todas as medicoes de uma missao
    Ordenacao: Por timestamp (cronologica)
    SQL: SELECT * FROM medicao WHERE id_missao = ? ORDER BY timestamp

13. get_estatisticas_medicoes(id_missao)
    Parametros: id_missao (int)
    Retorno: tuple - Estatisticas agregadas
    Formato: (total, temp_min, temp_max, temp_media,
              press_min, press_max, press_media)
    Descricao: Calcula estatisticas das medicoes
    Calculos:
    - COUNT(*): Total de medicoes
    - MIN(temperatura), MAX(temperatura), AVG(temperatura)
    - MIN(pressao), MAX(pressao), AVG(pressao)
    SQL: SELECT COUNT(*), MIN(temperatura), MAX(temperatura),
                AVG(temperatura), MIN(pressao), MAX(pressao), AVG(pressao)
         FROM medicao WHERE id_missao = ?

--------------------------------------------------------------------------------
                         OPERACOES DE VIDEO
--------------------------------------------------------------------------------

14. inserir_video(id_missao, caminho)
    Parametros:
    - id_missao (int): ID da missao
    - caminho (str): Caminho absoluto do arquivo de video
    Retorno: int - ID do video inserido
    Descricao: Registra um arquivo de video no banco
    Formato do Caminho: C:\...\videos_missoes\{identificador}_seg{num}_{timestamp}.avi
    SQL: INSERT INTO video (id_missao, caminho) VALUES (?, ?)

15. listar_videos_por_missao(id_missao)
    Parametros: id_missao (int)
    Retorno: list[tuple] - Lista de videos
    Formato: (id_video, id_missao, caminho)
    Descricao: Retorna todos os videos de uma missao
    Ordenacao: Por id_video (sequencia de gravacao)
    SQL: SELECT * FROM video WHERE id_missao = ?

--------------------------------------------------------------------------------
                         OPERACOES DE AUDIO
--------------------------------------------------------------------------------

16. inserir_audio(id_missao, caminho)
    Parametros:
    - id_missao (int): ID da missao
    - caminho (str): Caminho absoluto do arquivo de audio
    Retorno: int - ID do audio inserido
    Descricao: Registra um arquivo de audio no banco
    Formato do Caminho: C:\...\audios_missoes\{identificador}_seg{num}_{timestamp}.wav
    SQL: INSERT INTO audio (id_missao, caminho) VALUES (?, ?)

17. listar_audios_por_missao(id_missao)
    Parametros: id_missao (int)
    Retorno: list[tuple] - Lista de audios
    Formato: (id_audio, id_missao, caminho)
    Descricao: Retorna todos os audios de uma missao
    Ordenacao: Por id_audio (sequencia de gravacao)
    SQL: SELECT * FROM audio WHERE id_missao = ?

--------------------------------------------------------------------------------
                         OPERACOES EXTRAS
--------------------------------------------------------------------------------

18. deletar_missao(id_missao)
    Parametros: id_missao (int)
    Retorno: None
    Descricao: Deleta uma missao e todos os dados relacionados
    Efeito Cascade:
    - Remove automaticamente medicoes (ON DELETE CASCADE)
    - Remove automaticamente videos (ON DELETE CASCADE)
    - Remove automaticamente audios (ON DELETE CASCADE)
    NOTA: Nao remove os arquivos fisicos de video/audio do disco
    SQL: DELETE FROM missao WHERE id_missao = ?

19. contar_missoes()
    Parametros: None
    Retorno: int - Total de missoes
    Descricao: Retorna o numero total de missoes no banco
    SQL: SELECT COUNT(*) FROM missao

20. contar_mergulhadores()
    Parametros: None
    Retorno: int - Total de mergulhadores
    Descricao: Retorna o numero total de mergulhadores cadastrados
    SQL: SELECT COUNT(*) FROM mergulhador


================================================================================
                          4. MODULO 3: criar_missao.py
================================================================================

ARQUIVO: criar_missao.py
DESCRICAO: Interface para criacao de novas missoes de mergulho

--------------------------------------------------------------------------------
                              CLASSE PRINCIPAL
--------------------------------------------------------------------------------

CLASSE: CriarMissaoWindow
Responsabilidade: Gerenciar formulario de criacao de missao

ATRIBUTOS:
- window: Janela Toplevel do Tkinter
- mergulhador_selecionado: Tupla com dados do mergulhador escolhido
- label_mergulhador: Label que exibe mergulhador selecionado
- entry_responsavel: Campo de texto para nome da missao
- entry_data_inicio: Campo para data de inicio (DD/MM/AAAA)
- entry_hora_inicio: Campo para hora de inicio (HH:MM)

METODOS:

1. __init__(self, parent)
   Parametros: parent - Janela pai
   Retorno: None
   Descricao: Inicializa a janela de criacao de missao
   Acoes:
   - Cria janela Toplevel 700x450
   - Centraliza na tela
   - Inicializa variavel mergulhador_selecionado = None
   - Cria interface completa

2. centralizar_janela(self)
   Parametros: None
   Retorno: None
   Descricao: Centraliza a janela na tela
   (Mesmo algoritmo de main.py)

3. criar_interface(self)
   Parametros: None
   Retorno: None
   Descricao: Cria todos os elementos do formulario
   Secoes:
   a) Titulo: "Nova Missao de Mergulho"
   b) Secao Mergulhador:
      - Botao "Selecionar Mergulhador Existente"
      - Botao "Cadastrar Novo Mergulhador"
      - Label de status (mostra mergulhador selecionado)
   c) Secao Dados da Missao:
      - Campo: Nome da Missao (Entry de 40 chars)
      - Campo: Data Inicio (Entry com valor padrao = hoje)
      - Campo: Hora Inicio (Entry com valor padrao = hora atual)
      - Hint: "(DD/MM/AAAA HH:MM)"
   d) Botoes de Acao:
      - Botao "Criar Missao" (verde, 15x2)
      - Botao "Cancelar" (cinza, 15x2)

4. selecionar_mergulhador(self)
   Parametros: None
   Retorno: None
   Descricao: Abre janela para selecionar mergulhador existente
   Fluxo:
   1. Busca mergulhadores no banco (db.listar_mergulhadores())
   2. Se vazio, mostra aviso e retorna
   3. Cria janela de selecao 500x400
   4. Preenche Listbox com formato: "ID: X | Nome | Idade anos | Sexo: X"
   5. Botao "Confirmar":
      - Valida selecao
      - Armazena em self.mergulhador_selecionado
      - Atualiza label com dados do mergulhador
      - Fecha janela de selecao

5. cadastrar_mergulhador(self)
   Parametros: None
   Retorno: None
   Descricao: Abre janela para cadastrar novo mergulhador
   Fluxo:
   1. Cria janela 400x300
   2. Campos:
      - Nome (Entry de 30 chars)
      - Idade (Entry de 30 chars)
      - Sexo (RadioButtons: Masculino/Feminino/Outro)
   3. Botao "Salvar":
      Validacoes:
      - Nome nao pode estar vazio
      - Idade nao pode estar vazia
      - Idade deve ser numero inteiro positivo
      Se valido:
      - Insere no banco (db.inserir_mergulhador)
      - Armazena em self.mergulhador_selecionado
      - Atualiza label
      - Mostra mensagem de sucesso
      - Fecha janela de cadastro

6. criar_missao(self)
   Parametros: None
   Retorno: None
   Descricao: Cria a missao no banco e inicia gravacoes

   Validacoes:
   1. Verifica se ha missao em andamento:
      - Chama db.verificar_missao_em_andamento()
      - Se houver, mostra erro com detalhes da missao ativa e retorna

   2. Valida mergulhador:
      - Se nao selecionado, mostra erro e retorna

   3. Valida nome da missao:
      - Se vazio, mostra erro e retorna

   4. Valida data/hora:
      - Tenta converter para datetime
      - Formato esperado: DD/MM/AAAA HH:MM
      - Se invalido, mostra erro e retorna

   Processamento:
   1. Gera identificador: "Missao_DD-MM-AA_HH-MM"
   2. Insere missao no banco (db.inserir_missao)
   3. Conecta ao Arduino:
      - Obtem instancia singleton (sensor_arduino.get_sensor())
      - Se nao conectado, tenta conectar automaticamente
      - Inicia leitura continua (sensor.iniciar_leitura)
   4. Inicia gravacao de video:
      - Obtem instancia singleton (gravacao_video.get_gravador())
      - Inicia gravacao (iniciar_gravacao)
   5. Inicia gravacao de audio:
      - Obtem instancia singleton (gravacao_audio.get_gravador())
      - Inicia gravacao (iniciar_gravacao)
   6. Mostra mensagem de sucesso com:
      - Identificador da missao
      - Nome da missao
      - Nome do mergulhador
      - Data/hora de inicio
      - Status de gravacoes (Video, Audio, Sensores)
   7. Fecha janela


================================================================================
                          5. MODULO 4: visualizar_missoes.py
================================================================================

ARQUIVO: visualizar_missoes.py
DESCRICAO: Interface para visualizacao e reproducao de missoes

FUNCIONALIDADES:
- Listar todas as missoes (finalizadas e em andamento)
- Ver detalhes completos de uma missao
- Reproduzir videos com audio sincronizado
- Visualizar missao ao vivo
- Finalizar missao em andamento

NOTA: Este modulo nao foi lido completamente, mas baseado na exploracao inicial,
      contem as seguintes funcionalidades principais:

CLASSE: VisualizarMissoesWindow

METODOS PRINCIPAIS (estimados):

1. __init__(self, parent)
   - Inicializa janela de visualizacao
   - Cria tabela de missoes

2. listar_missoes_tabela(self)
   - Busca todas as missoes no banco
   - Preenche Treeview com colunas:
     * Identificador
     * Mergulhador
     * Nome da Missao
     * Inicio
     * Fim
     * Status (Em Andamento / Finalizada)

3. ver_detalhes(self)
   - Abre janela modal com:
     * Dados do mergulhador
     * Dados da missao
     * Lista de videos
     * Lista de audios
     * Tabela de medicoes
     * Estatisticas (temperatura e pressao: min/max/media)

4. visualizar_missao(self)
   - Se missao finalizada:
     * Reproduz videos em sequencia
     * Sincroniza audio
     * Controles: Q (sair), N (proximo segmento)
   - Se missao em andamento:
     * Exibe camera ao vivo
     * Mostra dados de sensores em tempo real

5. finalizar_missao(self)
   - Valida se missao esta em andamento
   - Para gravacoes:
     * Para gravador de video
     * Para gravador de audio
     * Para leitura de sensores
   - Atualiza data_hora_fim no banco
   - Atualiza tabela

6. reproduzir_videos(self, videos, audios)
   - Recebe listas de caminhos
   - Abre videos com OpenCV
   - Sincroniza audio com PyAudio/wave
   - Exibe informacoes sobrepostas:
     * Numero do segmento
     * Tempo decorrido
     * Temperatura e pressao
   - Permite navegar entre segmentos


================================================================================
                          6. MODULO 5: sensor_arduino.py
================================================================================

ARQUIVO: sensor_arduino.py
DESCRICAO: Comunicacao serial com Arduino para leitura de sensores

--------------------------------------------------------------------------------
                              CLASSE PRINCIPAL
--------------------------------------------------------------------------------

CLASSE: SensorArduino (Singleton)
Responsabilidade: Gerenciar comunicacao serial e leitura de sensores

PADRAO DE DESIGN: Singleton
Motivo: Garantir unica instancia de conexao serial

ATRIBUTOS DE CLASSE:
- _instancia: Instancia unica (None inicialmente)
- _lock: Lock para thread-safety na criacao da instancia

ATRIBUTOS DE INSTANCIA:
- initialized: Flag de inicializacao (evita reinicializacao)
- conectado: Boolean - Estado da conexao serial
- lendo: Boolean - Se esta lendo dados continuamente
- porta_serial: Objeto serial.Serial
- thread_leitura: Thread de leitura continua
- parar_flag: Flag para parar thread

Dados de Leitura:
- ultima_temperatura: Float ou None - Ultima leitura em Celsius
- ultima_pressao: Float ou None - Ultima leitura em PSI
- ultima_tensao: Float ou None - Ultima leitura em Volts
- ultimo_timestamp: datetime ou None - Timestamp da ultima leitura

Controle de Salvamento:
- id_missao: ID da missao ativa (None se nao houver)
- ultimo_salvamento: Timestamp do ultimo salvamento no banco
- intervalo_salvamento: 60 segundos (1 minuto)

Thread Safety:
- dados_lock: Lock para acesso thread-safe aos dados de leitura

METODOS:

1. __new__(cls)
   Parametros: cls - Classe
   Retorno: SensorArduino - Instancia unica
   Descricao: Implementa padrao Singleton
   Thread-safe: Usa double-checked locking

2. __init__(self)
   Parametros: None
   Retorno: None
   Descricao: Inicializa atributos (apenas uma vez)
   Verificacao: Se ja inicializado, retorna imediatamente

3. listar_portas_disponiveis(self)
   Parametros: None
   Retorno: list[tuple] - [(porta, descricao), ...]
   Descricao: Lista todas as portas COM disponiveis
   Usa: serial.tools.list_ports.comports()
   Formato: [('COM3', 'Arduino Uno'), ('COM5', 'USB Serial'), ...]

4. conectar(self, porta=None, baudrate=9600)
   Parametros:
   - porta (str, opcional): Nome da porta (ex: 'COM3')
   - baudrate (int, opcional): Taxa de transmissao (padrao: 9600)
   Retorno: bool - True se conectado, False caso contrario
   Descricao: Conecta ao Arduino

   Algoritmo:
   1. Se ja conectado, retorna False
   2. Se porta == None:
      - Lista portas disponiveis
      - Se nenhuma encontrada, retorna False
      - Usa primeira porta da lista
   3. Tenta abrir conexao serial:
      - Cria serial.Serial(porta, baudrate, timeout=1)
      - Aguarda 2 segundos (reset do Arduino)
      - Define conectado = True
      - Retorna True
   4. Em caso de erro:
      - Imprime mensagem de erro
      - Retorna False

5. desconectar(self)
   Parametros: None
   Retorno: None
   Descricao: Desconecta do Arduino
   Acoes:
   1. Se lendo, para leitura (chama parar_leitura)
   2. Se porta aberta, fecha porta serial
   3. Define conectado = False

6. iniciar_leitura(self, id_missao=None)
   Parametros: id_missao (int, opcional) - ID da missao ativa
   Retorno: bool - True se iniciado, False caso contrario
   Descricao: Inicia leitura continua dos sensores

   Validacoes:
   - Se nao conectado, retorna False
   - Se ja lendo, retorna False

   Acoes:
   1. Armazena id_missao
   2. Reseta flags (parar_flag=False, lendo=True)
   3. Reseta ultimo_salvamento = None
   4. Cria thread daemon (target=_ler_dados_continuamente)
   5. Inicia thread
   6. Retorna True

7. parar_leitura(self)
   Parametros: None
   Retorno: None
   Descricao: Para a leitura continua
   Acoes:
   1. Se nao lendo, retorna
   2. Define parar_flag = True
   3. Define lendo = False
   4. Aguarda thread finalizar (timeout 5s)

8. _ler_dados_continuamente(self)
   Parametros: None
   Retorno: None
   Descricao: Thread que le dados continuamente
   Privado: Nao deve ser chamado diretamente

   Loop Principal:
   while not parar_flag and porta aberta:
     1. Le linha da serial (readline)
     2. Decodifica UTF-8
     3. Remove espacos em branco
     4. Verifica se contem '|' (formato esperado)
     5. Parseia linha (chama _parsear_linha)
     6. Se temperatura e pressao validos:
        a) Atualiza dados com lock:
           - ultima_temperatura
           - ultima_pressao
           - ultima_tensao
           - ultimo_timestamp = datetime.now()
        b) Imprime no console
        c) Se id_missao ativo:
           - Verifica se passou 1 minuto desde ultimo salvamento
           - Se sim:
             * Converte timestamp para string
             * Insere medicao no banco (db.inserir_medicao)
             * Atualiza ultimo_salvamento
     7. Trata erros de leitura

   Finally:
   - Define lendo = False

9. _parsear_linha(self, linha)
   Parametros: linha (str) - Linha lida da serial
   Retorno: tuple - (temperatura, pressao, tensao)
   Descricao: Extrai valores numericos da linha

   Formato Esperado:
   "| Tens찾o: 2.450 V | Pressao: 14.63 psi | Temperatura = 25.3"

   Algoritmo:
   1. Usa regex para extrair tensao:
      Pattern: r'Tens찾o:\s*([\d.]+)\s*V'
   2. Usa regex para extrair pressao:
      Pattern: r'Pressao:\s*([\d.]+)\s*psi'
   3. Usa regex para extrair temperatura:
      Pattern: r'Temperatura\s*=\s*([\d.]+)'
   4. Converte para float
   5. Retorna tupla (temperatura, pressao, tensao)
   6. Em caso de erro, retorna (None, None, None)

10. get_ultima_leitura(self)
    Parametros: None
    Retorno: dict - Dicionario com ultima leitura
    Descricao: Retorna todos os dados da ultima leitura (thread-safe)

    Thread-Safety: Usa dados_lock

    Retorno:
    {
        'temperatura': float ou None,
        'pressao': float ou None,
        'tensao': float ou None,
        'timestamp': datetime ou None,
        'conectado': bool,
        'lendo': bool
    }

11. get_temperatura_formatada(self)
    Parametros: None
    Retorno: str - Temperatura formatada
    Descricao: Retorna temperatura em formato legivel
    Thread-Safety: Usa dados_lock
    Exemplos:
    - "25.3째C" se disponivel
    - "N/A" se nao disponivel

12. get_pressao_formatada(self)
    Parametros: None
    Retorno: str - Pressao formatada
    Descricao: Retorna pressao em formato legivel
    Thread-Safety: Usa dados_lock
    Exemplos:
    - "14.63 psi" se disponivel
    - "N/A" se nao disponivel

--------------------------------------------------------------------------------
                              FUNCAO EXTRA
--------------------------------------------------------------------------------

FUNCAO: get_sensor()
Parametros: None
Retorno: SensorArduino - Instancia unica
Descricao: Funcao de conveniencia para obter instancia singleton
Uso Recomendado: Sempre usar esta funcao ao inves de instanciar diretamente


================================================================================
                          7. MODULO 6: gravacao_video.py
================================================================================

ARQUIVO: gravacao_video.py
DESCRICAO: Gravacao automatica de video em background

--------------------------------------------------------------------------------
                              CLASSE PRINCIPAL
--------------------------------------------------------------------------------

CLASSE: GravadorVideo (Singleton)
Responsabilidade: Gerenciar gravacao automatica de video

PADRAO DE DESIGN: Singleton
Motivo: Garantir unica instancia de gravacao

ATRIBUTOS:
- _instancia, _lock: Controle de singleton
- initialized: Flag de inicializacao
- gravando: Boolean - Se esta gravando
- id_missao: ID da missao ativa
- thread_gravacao: Thread de gravacao
- parar_flag: Flag para parar gravacao
- diretorio_videos: "videos_missoes"

Frame Compartilhado (para visualizacao ao vivo):
- ultimo_frame: numpy.array - Ultimo frame capturado
- frame_lock: Lock para acesso thread-safe ao frame

METODOS:

1. __new__(cls)
   Descricao: Implementa singleton (mesmo padrao de SensorArduino)

2. __init__(self)
   Descricao: Inicializa atributos
   Acoes:
   - Cria diretorio videos_missoes se nao existir

3. iniciar_gravacao(self, id_missao, identificador_missao)
   Parametros:
   - id_missao (int): ID da missao
   - identificador_missao (str): Identificador da missao
   Retorno: bool - True se iniciado

   Validacoes:
   - Se ja gravando, retorna False

   Acoes:
   1. Armazena id_missao e identificador_missao
   2. Reseta flags (parar_flag=False, gravando=True)
   3. Cria thread daemon (target=_gravar_em_segmentos)
   4. Inicia thread
   5. Retorna True

4. parar_gravacao(self)
   Parametros: None
   Retorno: bool - True se parado
   Descricao: Para gravacao em andamento

   Acoes:
   1. Se nao gravando, retorna False
   2. Define parar_flag = True
   3. Define gravando = False
   4. Aguarda thread finalizar (timeout 10s)
   5. Limpa id_missao e identificador_missao
   6. Retorna True

5. _gravar_em_segmentos(self)
   Parametros: None
   Retorno: None
   Descricao: Thread que grava video em segmentos de 5 minutos
   Privado: Nao deve ser chamado diretamente

   Constante: DURACAO_SEGMENTO = 5 * 60 = 300 segundos

   Algoritmo:
   1. Abre camera (cv2.VideoCapture(0))
   2. Valida abertura da camera
   3. Obtem configuracoes:
      - fps = CAP_PROP_FPS (padrao 20 se nao obter)
      - largura = CAP_PROP_FRAME_WIDTH
      - altura = CAP_PROP_FRAME_HEIGHT
   4. Inicializa segmento_numero = 1

   Loop Principal:
   while not parar_flag:
     a) Cria nome do arquivo:
        - timestamp = YYYYMMDD_HHMMSS
        - nome = "{identificador}_seg{num:03d}_{timestamp}.avi"
        - caminho = caminho absoluto em videos_missoes/

     b) Configura VideoWriter:
        - codec = XVID
        - fps, largura, altura da camera

     c) Registra inicio do segmento:
        - tempo_inicio_segmento = time.time()
        - frames_gravados = 0

     d) Loop de Gravacao do Segmento:
        while not parar_flag:
          - Calcula tempo decorrido
          - Se >= 5 minutos, break (fecha segmento)
          - Captura frame (cap.read())
          - Se falha, break

          - Adiciona informacoes no frame:
            * Texto 1: "Missao: {id} | Seg: {num}"
            * Texto 2: "Tempo: {atual}s / 300s"
            * Texto 3: "Temp: {temp} | Pressao: {press}"
              (obtem de sensor_arduino.get_sensor())

          - Grava frame (out.write)
          - frames_gravados++

          - Armazena frame para visualizacao ao vivo (com lock)
          - Delay: 1.0 / fps (nao sobrecarregar CPU)

     e) Fecha arquivo de video (out.release())

     f) Se frames_gravados > 0:
        - Aguarda 0.5s (garantir escrita no disco)
        - Verifica se arquivo existe
        - Se existe:
          * Insere no banco (db.inserir_video)
        - Se nao existe:
          * Imprime erro

     g) Se frames_gravados == 0:
        - Remove arquivo vazio (os.remove)

     h) Se parar_flag, break (sai do loop principal)

     i) Incrementa segmento_numero

   5. Libera camera (cap.release())

   6. Trata excecoes gerais

6. esta_gravando(self)
   Parametros: None
   Retorno: bool
   Descricao: Verifica se ha gravacao em andamento

7. get_info_gravacao(self)
   Parametros: None
   Retorno: dict
   Descricao: Retorna informacoes da gravacao atual

   Se gravando:
   {
       'gravando': True,
       'id_missao': int,
       'identificador': str
   }

   Se nao gravando:
   {
       'gravando': False
   }

8. get_ultimo_frame(self)
   Parametros: None
   Retorno: numpy.array ou None
   Descricao: Retorna copia do ultimo frame (thread-safe)
   Uso: Visualizacao ao vivo de missao em andamento
   Thread-Safety: Usa frame_lock

--------------------------------------------------------------------------------
                              FUNCAO EXTRA
--------------------------------------------------------------------------------

FUNCAO: get_gravador()
Parametros: None
Retorno: GravadorVideo - Instancia unica
Descricao: Funcao de conveniencia para obter instancia singleton


================================================================================
                          8. MODULO 7: gravacao_audio.py
================================================================================

ARQUIVO: gravacao_audio.py
DESCRICAO: Gravacao automatica de audio em background

--------------------------------------------------------------------------------
                              CLASSE PRINCIPAL
--------------------------------------------------------------------------------

CLASSE: GravadorAudio (Singleton)
Responsabilidade: Gerenciar gravacao automatica de audio

PADRAO DE DESIGN: Singleton
Motivo: Garantir unica instancia de gravacao

ATRIBUTOS:
- _instancia, _lock: Controle de singleton
- initialized: Flag de inicializacao
- gravando: Boolean - Se esta gravando
- id_missao: ID da missao ativa
- thread_gravacao: Thread de gravacao
- parar_flag: Flag para parar gravacao
- diretorio_audios: "audios_missoes"

Configuracoes de Audio:
- CHUNK: 1024 - Tamanho do buffer
- FORMAT: pyaudio.paInt16 - Formato de amostragem (16-bit PCM)
- CHANNELS: 1 - Mono
- RATE: 44100 - Taxa de amostragem (44.1 kHz - qualidade CD)

METODOS:

1. __new__(cls)
   Descricao: Implementa singleton

2. __init__(self)
   Descricao: Inicializa atributos
   Acoes:
   - Define configuracoes de audio
   - Cria diretorio audios_missoes se nao existir

3. iniciar_gravacao(self, id_missao, identificador_missao)
   Parametros:
   - id_missao (int): ID da missao
   - identificador_missao (str): Identificador da missao
   Retorno: bool - True se iniciado

   (Mesmo comportamento de GravadorVideo.iniciar_gravacao)

4. parar_gravacao(self)
   Parametros: None
   Retorno: bool
   Descricao: Para gravacao em andamento

   (Mesmo comportamento de GravadorVideo.parar_gravacao)

5. _gravar_em_segmentos(self)
   Parametros: None
   Retorno: None
   Descricao: Thread que grava audio em segmentos de 5 minutos
   Privado: Nao deve ser chamado diretamente

   Constante: DURACAO_SEGMENTO = 5 * 60 = 300 segundos

   Algoritmo:
   1. Inicializa PyAudio (audio = pyaudio.PyAudio())

   2. Abre stream de audio:
      - format = paInt16
      - channels = 1 (mono)
      - rate = 44100
      - input = True (captura)
      - frames_per_buffer = 1024
      - Trata erro de abertura

   3. Inicializa segmento_numero = 1

   Loop Principal:
   while not parar_flag:
     a) Cria nome do arquivo:
        - timestamp = YYYYMMDD_HHMMSS
        - nome = "{identificador}_seg{num:03d}_{timestamp}.wav"
        - caminho = caminho absoluto em audios_missoes/

     b) Configura arquivo WAV:
        - wf = wave.open(caminho, 'wb')
        - setnchannels(1)
        - setsampwidth(audio.get_sample_size(paInt16))
        - setframerate(44100)

     c) Registra inicio do segmento:
        - tempo_inicio_segmento = time.time()
        - frames_gravados = 0

     d) Loop de Gravacao do Segmento:
        while not parar_flag:
          - Calcula tempo decorrido
          - Se >= 5 minutos, break
          - Le dados do microfone (stream.read(1024))
          - Grava no arquivo WAV (wf.writeframes)
          - frames_gravados++
          - Trata erro de captura

     e) Fecha arquivo WAV (wf.close())

     f) Se frames_gravados > 0:
        - Aguarda 0.5s
        - Verifica existencia do arquivo
        - Se existe, insere no banco (db.inserir_audio)
        - Se nao existe, imprime erro

     g) Se frames_gravados == 0:
        - Remove arquivo vazio

     h) Se parar_flag, break

     i) Incrementa segmento_numero

   4. Fecha stream e PyAudio:
      - stream.stop_stream()
      - stream.close()
      - audio.terminate()

   5. Trata excecoes gerais

6. esta_gravando(self)
   Parametros: None
   Retorno: bool
   Descricao: Verifica se ha gravacao de audio em andamento

7. get_info_gravacao(self)
   Parametros: None
   Retorno: dict
   Descricao: Retorna informacoes da gravacao de audio atual

   (Mesmo formato de GravadorVideo.get_info_gravacao)

--------------------------------------------------------------------------------
                              FUNCAO EXTRA
--------------------------------------------------------------------------------

FUNCAO: get_gravador()
Parametros: None
Retorno: GravadorAudio - Instancia unica
Descricao: Funcao de conveniencia para obter instancia singleton


================================================================================
                  9. MODULO 8: sensor_e_temperatura.ino (Arduino)
================================================================================

ARQUIVO: sensor_e_temperatura.ino
LINGUAGEM: C++ (Arduino)
DESCRICAO: Codigo para Arduino ler sensores de temperatura e pressao

--------------------------------------------------------------------------------
                              BIBLIOTECAS UTILIZADAS
--------------------------------------------------------------------------------

1. OneWire.h
   Descricao: Comunicacao com dispositivos OneWire
   Uso: Interface com sensor DS18B20

2. DallasTemperature.h
   Descricao: Biblioteca para sensores de temperatura Dallas/Maxim
   Uso: Facilita leitura do DS18B20

--------------------------------------------------------------------------------
                              CONSTANTES E VARIAVEIS
--------------------------------------------------------------------------------

PINO_ONEWIRE = 12
  Descricao: Pino digital conectado ao sensor DS18B20
  Tipo: const int

PINO_SENSOR = A0
  Descricao: Pino analogico conectado ao sensor de pressao
  Tipo: const int

oneWire
  Descricao: Objeto OneWire para comunicacao
  Tipo: OneWire
  Inicializacao: OneWire(PINO_ONEWIRE)

sensor
  Descricao: Objeto DallasTemperature para leitura de temperatura
  Tipo: DallasTemperature
  Inicializacao: DallasTemperature(&oneWire)

endereco_temp
  Descricao: Endereco temporario do sensor no barramento OneWire
  Tipo: DeviceAddress

--------------------------------------------------------------------------------
                              FUNCOES
--------------------------------------------------------------------------------

1. setup()
   Parametros: None
   Retorno: void
   Descricao: Funcao de inicializacao do Arduino
   Executado: Uma vez ao ligar/resetar o Arduino

   Acoes:
   1. Inicia comunicacao serial:
      - Serial.begin(9600)
      - Baudrate: 9600 bps
   2. Imprime mensagem inicial:
      - "Medindo Temperatura"
   3. Inicializa sensor de temperatura:
      - sensor.begin()

2. loop()
   Parametros: None
   Retorno: void
   Descricao: Funcao principal, executa continuamente
   Executado: Repetidamente em loop infinito

   Algoritmo:
   1. Le sensor de pressao:
      - leitura = analogRead(PINO_SENSOR)
      - Retorna valor 0-1023 (resolucao 10-bit)

   2. Solicita leitura de temperatura:
      - sensor.requestTemperatures()

   3. Obtem endereco do sensor no barramento:
      - sensor.getAddress(endereco_temp, 0)
      - Se falhar (sensor nao conectado):
        * Imprime "SENSOR NAO CONECTADO"
      - Se sucesso:

        a) Converte leitura ADC para tensao:
           Formula: tensao = leitura * (5.0 / 1023.0)
           Entrada: 0-1023
           Saida: 0.0-5.0 V

        b) Converte tensao para pressao:
           Formula: psi = (tensao - 0.5) * (30.0 / 4.0)
           Equivalente: psi = (tensao - 0.5) * 7.5

           Calibracao do Sensor:
           - 0.5 V = 0 psi
           - 4.5 V = 30 psi
           - Faixa linear: 0-30 psi

           Se psi < 0: psi = 0 (evita valores negativos)

        c) Obtem temperatura:
           temp = sensor.getTempC(endereco_temp)
           Retorna temperatura em graus Celsius

        d) Envia dados pela serial:
           Formato: "| Tens찾o: X.XXX V | Pressao: XX.XX psi | Temperatura = XX.X"

           Campos:
           - Tensao: 3 casas decimais
           - Pressao: 2 casas decimais
           - Temperatura: 1 casa decimal

   4. Aguarda 1 segundo:
      - delay(1000)
      - Intervalo de leitura: 1 Hz



